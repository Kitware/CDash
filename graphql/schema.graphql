"A datetime and timezone string in ISO 8601 format `Y-m-dTH:i:sP`, e.g. `2020-04-20T13:53:12+02:00`."
scalar DateTimeTz @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\DateTimeTz")

# It would be better to replace these with a "Duration" scalar type in the future.
"A non-negative decimal number of seconds."
scalar NonNegativeSeconds @scalar(class: "App\\GraphQL\\Scalars\\NonNegativeSeconds")
"A non-negative integer number of milliseconds."
scalar NonNegativeIntegerMilliseconds @scalar(class: "App\\GraphQL\\Scalars\\NonNegativeIntegerMilliseconds")


"Indicates what fields are available at the top level of a query operation."
type Query {
  "Find a single user by ID."
  me: User @auth

  "Find a single user by ID."
  user(
    id: ID @eq
  ): User @find

  "Get multiple users."
  users(
    filters: _ @filter(inputType: "UserFilterInput")
  ): [User!]! @paginate(type: CONNECTION) @orderBy(column: "id")

  "Find a single project."
  project(
    "Search by primary key."
    id: ID @eq @rules(apply: ["prohibits:name", "required_without:name"])

    "Search by name."
    name: String @eq @rules(apply: ["prohibits:id", "required_without:id"])
  ): Project @find(scopes: ["forUser"])

  "List the projects available to the current user."
  projects(
    filters: _ @filter(inputType: "ProjectFilterInput")
  ): [Project!]! @paginate(scopes: ["forUser"], type: CONNECTION) @orderBy(column: "id")

  "Find a single build by ID."
  build(
    "Search by primary key."
    id: ID @eq
  ): Build @find @canResolved(ability: "view")

  """
  Find a single site by ID.  All sites are currently public (although not necessarily
  the projects they contribute to).  In the future, the concept of "private sites"
  may be a good feature to add.
  """
  site(
    "Search by primary key."
    id: ID @eq
  ): Site @find

  invitations: [GlobalInvitation!]! @paginate(type: CONNECTION) @orderBy(column: "id")
}


type Mutation {
  "Create a new project."
  createProject(input: CreateProjectInput! @spread): Project @create @canModel(ability: "create")

  "Subscribe the current user to the specified site."
  claimSite(input: ClaimSiteInput! @spread): ClaimSiteMutationPayload! @field(resolver: "ClaimSite")

  "Unsubscribe the current user from the specified site."
  unclaimSite(input: UnclaimSiteInput! @spread): UnclaimSiteMutationPayload! @field(resolver: "UnclaimSite")

  "Edit the site description."
  updateSiteDescription(input: UpdateSiteDescriptionInput! @spread): UpdateSiteDescriptionMutationPayload! @field(resolver: "UpdateSiteDescription")

  "Add users to a project."
  inviteToProject(input: InviteToProjectInput! @spread): InviteToProjectMutationPayload! @field(resolver: "InviteToProject")

  "Revoke an outstanding project invitation."
  revokeProjectInvitation(input: RevokeProjectInvitationInput! @spread): RevokeProjectInvitationMutationPayload! @field(resolver: "RevokeProjectInvitation")

  "Change an existing user's role in a project."
  changeProjectRole(input: ChangeProjectRoleInput! @spread): ChangeProjectRoleMutationPayload! @field(resolver: "ChangeProjectRole")

  "Invite a user to this CDash instance by email."
  createGlobalInvitation(input: CreateGlobalInvitationInput! @spread): CreateGlobalInvitationMutationPayload! @field(resolver: "CreateGlobalInvitation")

  "Revoke an outstanding invitation."
  revokeGlobalInvitation(input: RevokeGlobalInvitationInput! @spread): RevokeGlobalInvitationMutationPayload! @field(resolver: "RevokeGlobalInvitation")

  "Change an existing user's site-wide role."
  changeGlobalRole(input: ChangeGlobalRoleInput! @spread): ChangeGlobalRoleMutationPayload! @field(resolver: "ChangeGlobalRole")

  "Delete a user."
  removeUser(input: RemoveUserInput! @spread): RemoveUserMutationPayload! @field(resolver: "RemoveUser")
}


interface MutationPayloadInterface {
  "Optional error message."
  message: String
}


"A registered CDash user.  Can be autogenerated by 3rd-party authentication providers."
type User {
  "Unique primary key."
  id: ID!

  "Non-unique first name."
  firstname: String!

  "Non-unique last name."
  lastname: String!

  "Unique email address."
  email: String @canRoot(ability: "viewEmail", action: RETURN_VALUE, returnValue: null)

  "Institution."
  institution: String!

  "Whether or not the user is a global administrator."
  admin: Boolean!
}

input UserFilterInput {
  id: ID
  firstname: String
  lastname: String
  institution: String
  admin: Boolean
}


"Project."
type Project {
  "Unique primary key."
  id: ID!

  "Unique name."
  name: String!

  "Description."
  description: String!

  "Homepage for this project."
  homeurl: String!

  "Visibility."
  visibility: ProjectVisibility! @rename(attribute: "public")

  "A boolean indicating whether authenticated submissions are required."
  authenticateSubmissions: Boolean! @rename(attribute: "authenticatesubmissions")

  "A LDAP group users must be a member of to access the project."
  ldapFilter: String @rename(attribute: "ldapfilter")

  builds(
    filters: _ @filter(inputType: "BuildFilterInput")
  ): [Build!]! @hasMany(type: CONNECTION) @orderBy(column: "id")

  """
  An efficient way to get the number of builds matching a given filter.
  """
  buildCount(
    filters: _ @filter(inputType: "BuildFilterInput")
  ): Int! @count(relation: "builds")

  """
  The most recent build submitted to this server.  Note: this is determined by
  submission time, not build start time.
  """
  mostRecentBuild: Build @hasOne

  "The sites which have submitted a build to this project."
  sites(
    filters: _ @filter(inputType: "SiteFilterInput")
  ): [Site!]! @belongsToMany(type: CONNECTION) @orderBy(column: "id")

  "Users with the lowest user role for this project."
  basicUsers: [User!]! @belongsToMany(type: CONNECTION) @orderBy(column: "id")

  "Users with the administrator role for this project."
  administrators: [User!]! @belongsToMany(type: CONNECTION) @orderBy(column: "id")

  "Invitations to this project which have not been accepted yet."
  invitations: [ProjectInvitation!]! @hasMany(type: CONNECTION) @orderBy(column: "id")
}

enum ProjectVisibility {
  "Available to all users and guests."
  PUBLIC @enum(value: 1)

  "Available to all registered users."
  PROTECTED @enum(value: 2)

  "Only available to users added to the project."
  PRIVATE @enum(value: 0)
}

input CreateProjectInput {
  "Unique name."
  name: String!

  "Description."
  description: String!

  "Project homepage"
  homeurl: String!

  "Visibility."
  visibility: ProjectVisibility! @rename(attribute: "public") @rules(attribute: "public", apply: ["App\\Rules\\ProjectVisibilityAllowed"])

  "A boolean indicating whether authenticated submissions are required."
  authenticateSubmissions: Boolean! @rename(attribute: "authenticatesubmissions") @rules(attribute: "authenticatesubmissions", apply: ["App\\Rules\\ProjectAuthenticateSubmissions"])

  "A LDAP group users must be a member of to access the project."
  ldapFilter: String @rename(attribute: "ldapfilter")
}

input ProjectFilterInput {
  id: ID
  name: String
  visibility: ProjectVisibility @rename(attribute: "public")
}


type ProjectInvitation {
  id: ID!

  email: String!

  invitedBy: User! @belongsTo

  project: Project! @belongsTo

  role: ProjectRole!

  invitationTimestamp: DateTimeTz! @rename(attribute: "invitation_timestamp")
}


input InviteToProjectInput {
  email: String!
  projectId: ID!
  role: ProjectRole!
}


type InviteToProjectMutationPayload implements MutationPayloadInterface {
  "Optional error message."
  message: String

  invitedUser: ProjectInvitation
}


input RevokeProjectInvitationInput {
  invitationId: ID!
}


type RevokeProjectInvitationMutationPayload implements MutationPayloadInterface {
  "Optional error message."
  message: String
}


input ChangeProjectRoleInput {
  userId: ID!
  projectId: ID!
  role: ProjectRole!
}


type ChangeProjectRoleMutationPayload implements MutationPayloadInterface {
  "Optional error message."
  message: String

  "The user whose role was changed."
  user: User

  "The project associated with the user whose role was changed."
  project: Project
}


type GlobalInvitation {
  id: ID!

  email: String!

  invitedBy: User! @belongsTo

  role: GlobalRole!

  invitationTimestamp: DateTimeTz! @rename(attribute: "invitation_timestamp")
}


input CreateGlobalInvitationInput {
  email: String!
  role: GlobalRole!
}


type CreateGlobalInvitationMutationPayload implements MutationPayloadInterface {
  "Optional error message."
  message: String

  invitedUser: GlobalInvitation
}


input RevokeGlobalInvitationInput {
  invitationId: ID!
}


type RevokeGlobalInvitationMutationPayload implements MutationPayloadInterface {
  "Optional error message."
  message: String
}


input ChangeGlobalRoleInput {
  userId: ID!
  role: GlobalRole!
}


type ChangeGlobalRoleMutationPayload implements MutationPayloadInterface {
  "Optional error message."
  message: String

  "The user whose role was changed."
  user: User
}


input RemoveUserInput {
  userId: ID!
}


type RemoveUserMutationPayload implements MutationPayloadInterface {
  "Optional error message."
  message: String
}


"Build."
type Build {
  "Unique primary key."
  id: ID!

  "Name."
  name: String!

  "Start time."
  startTime: DateTimeTz! @rename(attribute: "starttime")

  "End time."
  endTime: DateTimeTz! @rename(attribute: "endtime")

  "Submission time."
  submissionTime: DateTimeTz! @rename(attribute: "submittime")

  "The buildstamp generated by CTest. Example: 20091218-1414-Experimental"
  stamp: String!

  # TODO: Create a designated UUID GraphQL type
  "UUID."
  uuid: String!

  # TODO: Determine if there are more specific values we can use for this
  "Type."
  buildType: String! @rename(attribute: "type")

  "The version of CTest used to generate this build. Example: ctest-2.9.20091218"
  generator: String!

  "The command used to drive the build. Example: /usr/local/bin/cmake --build . --config Release"
  command: String!

  "The number of errors generated during the configuration step."
  configureErrorsCount: Int @rename(attribute: "configureerrors")

  "The number of warnings generated during the configuration step."
  configureWarningsCount: Int @rename(attribute: "configurewarnings")

  "The duration of the configure step in seconds."
  configureDuration: Int! @rename(attribute: "configureduration")

  "The number of errors generated during the build step."
  buildErrorsCount: Int @rename(attribute: "builderrors")

  "The number of warnings generated during the build step."
  buildWarningsCount: Int @rename(attribute: "buildwarnings")

  "The duration of the build step in seconds."
  buildDuration: Int! @rename(attribute: "buildduration")

  "The number of failed tests."
  failedTestsCount: Int @rename(attribute: "testfailed")

  "The number of tests which failed the time status."
  timeStatusFailedTestsCount: Int @rename(attribute: "testtimestatusfailed")

  "The number of passed tests."
  passedTestsCount: Int @rename(attribute: "testpassed")

  "The number of tests not run for this build."
  notRunTestsCount: Int @rename(attribute: "testnotrun")

  "The duration of the test step in seconds."
  testDuration: Int! @rename(attribute: "testduration")

  "The site associated with this build."
  site: Site! @belongsTo

  "Test results associated with this build."
  tests(
    filters: _ @filter(inputType: "TestFilterInput")
  ): [Test!]! @hasMany(type: CONNECTION) @orderBy(column: "id", direction: DESC)

  # TODO: Make an "errors" field which returns the union of basic and rich errors
  """
  A list of "basic" errors submitted for this build.
  """
  basicErrors: [BasicBuildAlert!]! @hasMany(type: CONNECTION) @orderBy(column: "id", direction: DESC)

  # TODO: Make a "warnings" field which returns the union of basic and rich warnings
  """
  A list of "basic" warnings submitted for this build.
  """
  basicWarnings: [BasicBuildAlert!]! @hasMany(type: CONNECTION) @orderBy(column: "id", direction: DESC)

  project: Project! @belongsTo

  notes: [Note!]! @belongsToMany(type: CONNECTION) @orderBy(column: "id", direction: DESC)

  operatingSystemName: String @rename(attribute: "osname")

  operatingSystemPlatform: String @rename(attribute: "osplatform")

  operatingSystemRelease: String @rename(attribute: "osrelease")

  operatingSystemVersion: String @rename(attribute: "osversion")

  compilerName: String @rename(attribute: "compilername")

  compilerVersion: String @rename(attribute: "compilerversion")

  """
  Child builds associated wirh this parent build.  Note that CDash only supports one level of
  subprojects, so no child builds will have children of their own.
  """
  children(
    filters: _ @filter(inputType: "BuildFilterInput")
  ): [Build!]! @hasMany(type: CONNECTION) @orderBy(column: "id")

  coverageResults(
    filters: _ @filter(inputType: "CoverageFilterInput")
  ): [Coverage!]! @belongsToMany(type: CONNECTION) @orderBy(column: "id", direction: DESC)

  labels(
    filters: _ @filter(inputType: "LabelFilterInput")
  ): [Label!]! @belongsToMany(type: CONNECTION) @orderBy(column: "id", direction: DESC)

  targets(
    filters: _ @filter(inputType: "TargetFilterInput")
  ): [Target!]! @hasMany(type: CONNECTION) @orderBy(column: "id", direction: ASC)

  commands(
    filters: _ @filter(inputType: "BuildCommandFilterInput")
  ): [BuildCommand!]! @hasMany(type: CONNECTION) @orderBy(column: "id", direction: ASC)
}

input BuildFilterInput {
  id: ID
  name: String
  startTime: DateTimeTz @rename(attribute: "starttime")
  endTime: DateTimeTz @rename(attribute: "endtime")
  submissionTime: DateTimeTz @rename(attribute: "submittime")
  stamp: String
  uuid: String
  operatingSystemName: String @rename(attribute: "osname")
  operatingSystemPlatform: String @rename(attribute: "osplatform")
  operatingSystemRelease: String @rename(attribute: "osrelease")
  operatingSystemVersion: String @rename(attribute: "osversion")
  compilerName: String @rename(attribute: "compilername")
  compilerVersion: String @rename(attribute: "compilerversion")
}


"Test."
type Test {
  "Unique primary key."
  id: ID!

  name: String! @rename(attribute: "testname")

  status: TestStatus!

  runningTime: NonNegativeSeconds! @rename(attribute: "time")

  details: String!

  """
  Test measurements for this test, sorted in descending order so newer results
  appear first when using paginated queries.
  """
  testMeasurements: [TestMeasurement!]! @hasMany(type: CONNECTION) @orderBy(column: "id", direction: DESC)

  labels(
    filters: _ @filter(inputType: "LabelFilterInput")
  ): [Label!]! @belongsToMany(type: CONNECTION) @orderBy(column: "id", direction: DESC)
}

enum TestStatus {
  PASSED @enum(value: "passed")

  FAILED @enum(value: "failed")

  TIMEOUT @enum(value: "Timeout")

  NOT_RUN @enum(value: "notrun")

  DISABLED @enum(value: "Disabled")
}

input TestFilterInput {
  id: ID
  name: String @rename(attribute: "testname")
  status: TestStatus
  runningTime: NonNegativeSeconds @rename(attribute: "time")
  details: String
}


"Test Measurement."
type TestMeasurement {
  "Unique primary key."
  id: ID!

  """
  Example: "Exit Value"
  """
  name: String!

  """
  Example: "text/string", "numeric/double", "text/preformatted", etc
  """
  type: String!

  """
  The value for this measurement.  Even though some values may be numeric, all
  values are returned as strings.  There is no guarantee that the type field
  will match the actual type of the value field.

  Example: "5"
  """
  value: String!
}


"""
Represents a command run during the build step.

https://cmake.org/cmake/help/git-master/manual/cmake-instrumentation.7.html#v1-snippet-file
"""
type BuildCommand @model(class: "App\\Models\\BuildCommand") {
  id: ID!

  type: BuildCommandType!

  startTime: DateTimeTz! @rename(attribute: "starttime")

  duration: NonNegativeIntegerMilliseconds!

  command: String!

  workingDirectory: String! @rename(attribute: "workingdirectory")

  result: String!

  source: String

  language: String

  config: String

  target: Target @belongsTo

  measurements(
    filters: _ @filter(inputType: "BuildMeasurementFilterInput")
  ): [BuildMeasurement!]! @hasMany(type: CONNECTION) @orderBy(column: "id", direction: ASC)

  """
  Output filenames and corresponding sizes associated with this command.  Most command types only
  produce one output file.
  """
  outputs(
    filters: _ @filter(inputType: "BuildCommandOutputFilterInput")
  ): [BuildCommandOutput!]! @hasMany(type: CONNECTION) @orderBy(column: "id", direction: ASC)
}

input BuildCommandFilterInput {
  id: ID
  type: BuildCommandType
  startTime: DateTimeTz @rename(attribute: "starttime")
  duration: NonNegativeIntegerMilliseconds
  command: String
  workingDirectory: String @rename(attribute: "workingdirectory")
  result: String
  source: String
  language: String
  config: String
}


"Build Measurement."
type BuildMeasurement {
  "Unique primary key."
  id: ID!

  name: String!

  type: String!

  """
  The value for this measurement.  Even though some values may be numeric, all
  values are returned as strings.  The type of the value field is not guaranteed
  to match the actual type of the value field.

  Example: "5"
  """
  value: String!
}


input BuildMeasurementFilterInput {
  id: ID
  name: String
  type: String
  value: String
}


"An individual file produced by a build command."
type BuildCommandOutput {
  "Unique primary key."
  id: ID!

  "Output filename."
  name: String!

  "Output file size in bytes."
  size: Int!
}


input BuildCommandOutputFilterInput {
  id: ID
  name: String
  size: Int
}


"""
"Basic" alerts are warnings or errors scraped from the build log, as opposed to "rich" alerts which
come from CTest launchers.  A given build should either have all "basic" alerts or all "rich" alerts.
Users should take both types into account when querying the alerts for a given build.

https://cmake.org/cmake/help/latest/manual/ctest.1.html#ctest-build-step
"""
type BasicBuildAlert {
  logLine: Int! @rename(attribute: "logline")

  text: String!

  sourceFile: String! @rename(attribute: "sourcefile")

  sourceLine: Int! @rename(attribute: "sourceline")

  preContext: String @rename(attribute: "precontext")

  postContext: String @rename(attribute: "postcontext")
}


"Site."
type Site {
  "Unique primary key."
  id: ID!

  name: String!

  "IP address."
  ip: String!

  latitude: String!

  longitude: String!

  "Every edit of this site's information."
  information: [SiteInformation!]! @hasMany(type: CONNECTION) @orderBy(column: "timestamp", direction: DESC)

  "The most recent information we have about this site."
  # TODO: Figure out how to support the date parameter. Perhaps it would be better to use a scope instead.
  mostRecentInformation: SiteInformation @hasOne

  "The users who have signed up to maintain this site."
  maintainers(
    filters: _ @filter(inputType: "UserFilterInput")
  ): [User!]! @belongsToMany(type: CONNECTION) @orderBy(column: "id")
}

input SiteFilterInput {
  id: ID
  name: String
  ip: String
  latitude: Float
  longitude: Float
}

input ClaimSiteInput {
  siteId: ID!
}

type ClaimSiteMutationPayload implements MutationPayloadInterface {
  "Optional error message."
  message: String

  "Site being claimed."
  site: Site

  "The user claiming the requested site."
  user: User
}

type UnclaimSiteMutationPayload implements MutationPayloadInterface {
  "Optional error message."
  message: String

  "Site being unclaimed."
  site: Site

  "The user being detached from the requested site."
  user: User
}

input UnclaimSiteInput {
  siteId: ID!
}

input UpdateSiteDescriptionInput {
  siteId: ID!
  description: String!
}

type UpdateSiteDescriptionMutationPayload implements MutationPayloadInterface {
  "Optional error message."
  message: String

  site: Site
}


"Details about a site at a given point in time."
type SiteInformation {
  "Unique primary key."
  id: ID!

  "Creation timestamp."
  timestamp: DateTimeTz!

  processorIs64Bits: Boolean @rename(attribute: "processoris64bits")

  processorVendor: String @rename(attribute: "processorvendor")

  processorVendorId: String @rename(attribute: "processorvendorid")

  processorFamilyId: Int @rename(attribute: "processorfamilyid")

  processorModelId: Int @rename(attribute: "processormodelid")

  processorModelName: String @rename(attribute: "processormodelname")

  processorCacheSize: Int @rename(attribute: "processorcachesize")

  numberLogicalCpus: Int @rename(attribute: "numberlogicalcpus")

  numberPhysicalCpus: Int @rename(attribute: "numberphysicalcpus")

  "Virtual memory in MiB."
  totalVirtualMemory: Int @rename(attribute: "totalvirtualmemory")

  "Physical memory in MiB."
  totalPhysicalMemory: Int @rename(attribute: "totalphysicalmemory")

  logicalProcessorsPerPhysical: Int @rename(attribute: "logicalprocessorsperphysical")

  "Clock frequency in MHz."
  processorClockFrequency: Int @rename(attribute: "processorclockfrequency")

  description: String
}


"""
Note.
"""
type Note {
  "Unique primary key."
  id: ID!

  name: String!

  text: String!
}

input NoteFilterInput {
  id: ID
  name: String
  text: String
}


"""
Coverage result for a particular build+file combination.
"""
type Coverage {
  "Unique primary key."
  id: ID!

  linesOfCodeTested: Int! @rename(attribute: "loctested")

  linesOfCodeUntested: Int! @rename(attribute: "locuntested")

  branchesTested: Int! @rename(attribute: "branchestested")

  branchesUntested: Int! @rename(attribute: "branchesuntested")

  functionsTested: Int! @rename(attribute: "functionstested")

  functionsUntested: Int! @rename(attribute: "functionsuntested")
}

input CoverageFilterInput {
  id: ID
  linesOfCodeTested: Int @rename(attribute: "loctested")
  linesOfCodeUntested: Int @rename(attribute: "locuntested")
  branchesTested: Int @rename(attribute: "branchestested")
  branchesUntested: Int @rename(attribute: "branchesuntested")
  functionsTested: Int @rename(attribute: "functionstested")
  functionsUntested: Int @rename(attribute: "functionsuntested")
}


"""
Label.
"""
type Label {
  "Unique primary key."
  id: ID!

  text: String!
}

input LabelFilterInput {
  id: ID
  text: String
}


"""
Target.
"""
type Target {
  "Unique primary key."
  id: ID!

  name: String!

  """
  https://cmake.org/cmake/help/latest/prop_tgt/TYPE.html
  """
  type: TargetType!

  commands(
    filters: _ @filter(inputType: "BuildCommandFilterInput")
  ): [BuildCommand!]! @hasMany(type: CONNECTION) @orderBy(column: "id", direction: ASC)

  labels(
    filters: _ @filter(inputType: "LabelFilterInput")
  ): [Label!]! @belongsToMany(type: CONNECTION) @orderBy(column: "id", direction: DESC)
}

input TargetFilterInput {
  id: ID
  name: String
  type: TargetType
}
