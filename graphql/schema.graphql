"A datetime and timezone string in ISO 8601 format `Y-m-dTH:i:sP`, e.g. `2020-04-20T13:53:12+02:00`."
scalar DateTimeTz @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\DateTimeTz")

# It would be better to replace this with a "Duration" scalar type in the future.
"A non-negative decimal number of seconds."
scalar NonNegativeSeconds @scalar(class: "App\\GraphQL\\Scalars\\NonNegativeSeconds")


"Indicates what fields are available at the top level of a query operation."
type Query {
  "Find a single project."
  project(
    "Search by primary key."
    id: ID @eq @rules(apply: ["prohibits:name", "required_without:name"])

    "Search by name."
    name: String @eq @rules(apply: ["prohibits:id", "required_without:id"])
  ): Project @find(scopes: ["forUser"])

  "List the projects available to the current user."
  projects(
    filters: _ @filter(inputType: "ProjectFilterInput")
  ): [Project!]! @paginate(scopes: ["forUser"], type: CONNECTION) @orderBy(column: "id")

  "Find a single build by ID."
  build(
    "Search by primary key."
    id: ID @eq
  ): Build @find @canResolved(ability: "view")

  """
  Find a single site by ID.  All sites are currently public (although not necessarily
  the projects they contribute to).  In the future, the concept of "private sites"
  may be a good feature to add.
  """
  site(
    "Search by primary key."
    id: ID @eq
  ): Site @find
}


type Mutation {
  "Create a new project."
  createProject(input: CreateProjectInput! @spread): Project @create @canModel(ability: "create")

  "Subscribe the current user to the specified site."
  claimSite(input: ClaimSiteInput! @spread): ClaimSiteMutationPayload! @field(resolver: "ClaimSite")

  "Unsubscribe the current user from the specified site."
  unclaimSite(input: UnclaimSiteInput! @spread): UnclaimSiteMutationPayload! @field(resolver: "UnclaimSite")

  "Edit the site description."
  updateSiteDescription(input: UpdateSiteDescriptionInput! @spread): UpdateSiteDescriptionMutationPayload! @field(resolver: "UpdateSiteDescription")

  "Add users to a project."
  inviteToProject(input: InviteToProjectInput! @spread): InviteToProjectMutationPayload! @field(resolver: "InviteToProject")

  "Revoke previous project invite."
  revokeInvitation(input: RevokeInvitationInput! @spread): RevokeInvitationMutationPayload! @field(resolver: "RevokeInvitation")

  "Change an existing user's role in a project."
  changeProjectRole(input: ChangeProjectRoleInput! @spread): ChangeProjectRoleMutationPayload! @field(resolver: "ChangeProjectRole")
}


interface MutationPayloadInterface {
  "Optional error message."
  message: String
}


"A registered CDash user.  Can be autogenerated by 3rd-party authentication providers."
type User {
  "Unique primary key."
  id: ID!

  "Non-unique first name."
  firstname: String!

  "Non-unique last name."
  lastname: String!

  "Unique email address."
  email: String!

  "Institution."
  institution: String!

  "Whether or not the user is a global administrator."
  admin: Boolean!
}

input UserFilterInput {
  id: ID
  firstname: String
  lastname: String
  email: String
  institution: String
  admin: Boolean
}


"Project."
type Project {
  "Unique primary key."
  id: ID!

  "Unique name."
  name: String!

  "Description."
  description: String!

  "Homepage for this project."
  homeurl: String!

  "Visibility."
  visibility: ProjectVisibility! @rename(attribute: "public")

  "A boolean indicating whether authenticated submissions are required."
  authenticateSubmissions: Boolean! @rename(attribute: "authenticatesubmissions")

  "A LDAP group users must be a member of to access the project."
  ldapFilter: String @rename(attribute: "ldapfilter")

  builds(
    filters: _ @filter(inputType: "BuildFilterInput")
  ): [Build!]! @hasMany(type: CONNECTION) @orderBy(column: "id")

  """
  An efficient way to get the number of builds matching a given filter.
  """
  buildCount(
    filters: _ @filter(inputType: "BuildFilterInput")
  ): Int! @count(relation: "builds")

  """
  The most recent build submitted to this server.  Note: this is determined by
  submission time, not build start time.
  """
  mostRecentBuild: Build @hasOne

  "The sites which have submitted a build to this project."
  sites(
    filters: _ @filter(inputType: "SiteFilterInput")
  ): [Site!]! @belongsToMany(type: CONNECTION) @orderBy(column: "id")

  "Users with the lowest user role for this project."
  basicUsers: [User!]! @belongsToMany(type: CONNECTION) @orderBy(column: "id")

  "Users with the administrator role for this project."
  administrators: [User!]! @belongsToMany(type: CONNECTION) @orderBy(column: "id")

  "Invitations to this project which have not been accepted yet."
  invitations: [UserInvitation!]! @hasMany(type: CONNECTION) @orderBy(column: "id")
}

enum ProjectVisibility {
  "Available to all users and guests."
  PUBLIC @enum(value: 1)

  "Available to all registered users."
  PROTECTED @enum(value: 2)

  "Only available to users added to the project."
  PRIVATE @enum(value: 0)
}

input CreateProjectInput {
  "Unique name."
  name: String!

  "Description."
  description: String!

  "Project homepage"
  homeurl: String!

  "Visibility."
  visibility: ProjectVisibility! @rename(attribute: "public") @rules(attribute: "public", apply: ["App\\Rules\\ProjectVisibilityAllowed"])

  "A boolean indicating whether authenticated submissions are required."
  authenticateSubmissions: Boolean! @rename(attribute: "authenticatesubmissions") @rules(attribute: "authenticatesubmissions", apply: ["App\\Rules\\ProjectAuthenticateSubmissions"])

  "A LDAP group users must be a member of to access the project."
  ldapFilter: String @rename(attribute: "ldapfilter")
}

input ProjectFilterInput {
  id: ID
  name: String
  visibility: ProjectVisibility @rename(attribute: "public")
}


type UserInvitation {
  id: ID!

  email: String!

  invitedBy: User! @belongsTo

  project: Project! @belongsTo

  role: ProjectRole!

  invitationTimestamp: DateTimeTz! @rename(attribute: "invitation_timestamp")
}


input InviteToProjectInput {
  email: String!
  projectId: ID!
  role: ProjectRole!
}


type InviteToProjectMutationPayload implements MutationPayloadInterface {
  "Optional error message."
  message: String

  invitedUser: UserInvitation
}


input RevokeInvitationInput {
  invitationId: ID!
}


type RevokeInvitationMutationPayload implements MutationPayloadInterface {
  "Optional error message."
  message: String
}


input ChangeProjectRoleInput {
  userId: ID!
  projectId: ID!
  role: ProjectRole!
}


type ChangeProjectRoleMutationPayload implements MutationPayloadInterface {
  "Optional error message."
  message: String

  "The user whose role was changed."
  user: User

  "The project associated with the user whose role was changed."
  project: Project
}


"Build."
type Build {
  "Unique primary key."
  id: ID!

  "Name."
  name: String!

  "Start time."
  startTime: DateTimeTz! @rename(attribute: "starttime")

  "End time."
  endTime: DateTimeTz! @rename(attribute: "endtime")

  "Submission time."
  submissionTime: DateTimeTz! @rename(attribute: "submittime")

  "The buildstamp generated by CTest. Example: 20091218-1414-Experimental"
  stamp: String!

  # TODO: Create a designated UUID GraphQL type
  "UUID."
  uuid: String!

  # TODO: Determine if there are more specific values we can use for this
  "Type."
  buildType: String! @rename(attribute: "type")

  "The version of CTest used to generate this build. Example: ctest-2.9.20091218"
  generator: String!

  "The command used to drive the build. Example: /usr/local/bin/cmake --build . --config Release"
  command: String!

  "The number of errors generated during the configuration step."
  configureErrorsCount: Int @rename(attribute: "configureerrors")

  "The number of warnings generated during the configuration step."
  configureWarningsCount: Int @rename(attribute: "configurewarnings")

  "The duration of the configure step in seconds."
  configureDuration: Int! @rename(attribute: "configureduration")

  "The number of errors generated during the build step."
  buildErrorsCount: Int @rename(attribute: "builderrors")

  "The number of warnings generated during the build step."
  buildWarningsCount: Int @rename(attribute: "buildwarnings")

  "The duration of the build step in seconds."
  buildDuration: Int! @rename(attribute: "buildduration")

  "The number of failed tests."
  failedTestsCount: Int @rename(attribute: "testfailed")

  "The number of tests which failed the time status."
  timeStatusFailedTestsCount: Int @rename(attribute: "testtimestatusfailed")

  "The number of passed tests."
  passedTestsCount: Int @rename(attribute: "testpassed")

  "The number of tests not run for this build."
  notRunTestsCount: Int @rename(attribute: "testnotrun")

  "The duration of the test step in seconds."
  testDuration: Int! @rename(attribute: "testduration")

  "The site associated with this build."
  site: Site! @belongsTo

  "Test results associated with this build."
  tests(
    filters: _ @filter(inputType: "TestFilterInput")
  ): [Test!]! @hasMany(type: CONNECTION) @orderBy(column: "id", direction: DESC)

  # TODO: Make an "errors" field which returns the union of basic and rich errors
  """
  A list of "basic" errors submitted for this build.
  """
  basicErrors: [BasicBuildAlert!]! @hasMany(type: CONNECTION) @orderBy(column: "id", direction: DESC)

  # TODO: Make a "warnings" field which returns the union of basic and rich warnings
  """
  A list of "basic" warnings submitted for this build.
  """
  basicWarnings: [BasicBuildAlert!]! @hasMany(type: CONNECTION) @orderBy(column: "id", direction: DESC)

  project: Project! @belongsTo

  notes: [Note!]! @belongsToMany(type: CONNECTION) @orderBy(column: "id", direction: DESC)

  measurements(
    filters: _ @filter(inputType: "BuildMeasurementFilterInput")
  ): [BuildMeasurement!]! @belongsToMany(type: CONNECTION) @orderBy(column: "id", direction: DESC)

  operatingSystemName: String @rename(attribute: "osname")

  operatingSystemPlatform: String @rename(attribute: "osplatform")

  operatingSystemRelease: String @rename(attribute: "osrelease")

  operatingSystemVersion: String @rename(attribute: "osversion")

  compilerName: String @rename(attribute: "compilername")

  compilerVersion: String @rename(attribute: "compilerversion")

  coverageResults(
    filters: _ @filter(inputType: "CoverageFilterInput")
  ): [Coverage!]! @belongsToMany(type: CONNECTION) @orderBy(column: "id", direction: DESC)

  labels(
    filters: _ @filter(inputType: "LabelFilterInput")
  ): [Label!]! @belongsToMany(type: CONNECTION) @orderBy(column: "id", direction: DESC)
}

input BuildFilterInput {
  id: ID
  name: String
  startTime: DateTimeTz @rename(attribute: "starttime")
  endTime: DateTimeTz @rename(attribute: "endtime")
  submissionTime: DateTimeTz @rename(attribute: "submittime")
  stamp: String
  uuid: String
  operatingSystemName: String @rename(attribute: "osname")
  operatingSystemPlatform: String @rename(attribute: "osplatform")
  operatingSystemRelease: String @rename(attribute: "osrelease")
  operatingSystemVersion: String @rename(attribute: "osversion")
  compilerName: String @rename(attribute: "compilername")
  compilerVersion: String @rename(attribute: "compilerversion")
}


"Test."
type Test {
  "Unique primary key."
  id: ID!

  name: String! @rename(attribute: "testname")

  status: TestStatus!

  runningTime: NonNegativeSeconds! @rename(attribute: "time")

  details: String!

  """
  Test measurements for this test, sorted in descending order so newer results
  appear first when using paginated queries.
  """
  testMeasurements: [TestMeasurement!]! @hasMany(type: CONNECTION) @orderBy(column: "id", direction: DESC)

  labels(
    filters: _ @filter(inputType: "LabelFilterInput")
  ): [Label!]! @belongsToMany(type: CONNECTION) @orderBy(column: "id", direction: DESC)
}

enum TestStatus {
  PASSED @enum(value: "passed")

  FAILED @enum(value: "failed")

  TIMEOUT @enum(value: "Timeout")

  NOT_RUN @enum(value: "notrun")

  DISABLED @enum(value: "Disabled")
}

input TestFilterInput {
  id: ID
  name: String @rename(attribute: "testname")
  status: TestStatus
  runningTime: NonNegativeSeconds @rename(attribute: "time")
  details: String
}


"Test Measurement."
type TestMeasurement {
  "Unique primary key."
  id: ID!

  """
  Example: "Exit Value"
  """
  name: String!

  """
  Example: "text/string", "numeric/double", "text/preformatted", etc
  """
  type: String!

  """
  The value for this measurement.  Even though some values may be numeric, all
  values are returned as strings.  There is no guarantee that the type field
  will match the actual type of the value field.

  Example: "5"
  """
  value: String!
}


"Build Measurement."
type BuildMeasurement {
  "Unique primary key."
  id: ID!

  name: String!

  source: String!

  type: BuildMeasurementType!

  """
  The value for this measurement.  Even though some values may be numeric, all
  values are returned as strings.

  Example: "5"
  """
  value: String!
}


input BuildMeasurementFilterInput {
  id: ID
  name: String
  source: String
  type: BuildMeasurementType
  value: String
}


"""
"Basic" alerts are warnings or errors scraped from the build log, as opposed to "rich" alerts which
come from CTest launchers.  A given build should either have all "basic" alerts or all "rich" alerts.
Users should take both types into account when querying the alerts for a given build.

https://cmake.org/cmake/help/latest/manual/ctest.1.html#ctest-build-step
"""
type BasicBuildAlert {
  logLine: Int! @rename(attribute: "logline")

  text: String!

  sourceFile: String! @rename(attribute: "sourcefile")

  sourceLine: Int! @rename(attribute: "sourceline")

  preContext: String @rename(attribute: "precontext")

  postContext: String @rename(attribute: "postcontext")
}


"Site."
type Site {
  "Unique primary key."
  id: ID!

  name: String!

  "IP address."
  ip: String!

  latitude: String!

  longitude: String!

  "Every edit of this site's information."
  information: [SiteInformation!]! @hasMany(type: CONNECTION) @orderBy(column: "timestamp", direction: DESC)

  "The most recent information we have about this site."
  # TODO: Figure out how to support the date parameter. Perhaps it would be better to use a scope instead.
  mostRecentInformation: SiteInformation @hasOne

  "The users who have signed up to maintain this site."
  maintainers(
    filters: _ @filter(inputType: "UserFilterInput")
  ): [User!]! @belongsToMany(type: CONNECTION) @orderBy(column: "id")
}

input SiteFilterInput {
  id: ID
  name: String
  ip: String
  latitude: Float
  longitude: Float
}

input ClaimSiteInput {
  siteId: ID!
}

type ClaimSiteMutationPayload implements MutationPayloadInterface {
  "Optional error message."
  message: String

  "Site being claimed."
  site: Site

  "The user claiming the requested site."
  user: User
}

type UnclaimSiteMutationPayload implements MutationPayloadInterface {
  "Optional error message."
  message: String

  "Site being unclaimed."
  site: Site

  "The user being detached from the requested site."
  user: User
}

input UnclaimSiteInput {
  siteId: ID!
}

input UpdateSiteDescriptionInput {
  siteId: ID!
  description: String!
}

type UpdateSiteDescriptionMutationPayload implements MutationPayloadInterface {
  "Optional error message."
  message: String

  site: Site
}


"Details about a site at a given point in time."
type SiteInformation {
  "Unique primary key."
  id: ID!

  "Creation timestamp."
  timestamp: DateTimeTz!

  processorIs64Bits: Boolean @rename(attribute: "processoris64bits")

  processorVendor: String @rename(attribute: "processorvendor")

  processorVendorId: String @rename(attribute: "processorvendorid")

  processorFamilyId: Int @rename(attribute: "processorfamilyid")

  processorModelId: Int @rename(attribute: "processormodelid")

  processorModelName: String @rename(attribute: "processormodelname")

  processorCacheSize: Int @rename(attribute: "processorcachesize")

  numberLogicalCpus: Int @rename(attribute: "numberlogicalcpus")

  numberPhysicalCpus: Int @rename(attribute: "numberphysicalcpus")

  "Virtual memory in MiB."
  totalVirtualMemory: Int @rename(attribute: "totalvirtualmemory")

  "Physical memory in MiB."
  totalPhysicalMemory: Int @rename(attribute: "totalphysicalmemory")

  logicalProcessorsPerPhysical: Int @rename(attribute: "logicalprocessorsperphysical")

  "Clock frequency in MHz."
  processorClockFrequency: Int @rename(attribute: "processorclockfrequency")

  description: String
}


"""
Note.
"""
type Note {
  "Unique primary key."
  id: ID!

  name: String!

  text: String!
}

input NoteFilterInput {
  id: ID
  name: String
  text: String
}


"""
Coverage result for a particular build+file combination.
"""
type Coverage {
  "Unique primary key."
  id: ID!

  linesOfCodeTested: Int! @rename(attribute: "loctested")

  linesOfCodeUntested: Int! @rename(attribute: "locuntested")

  branchesTested: Int! @rename(attribute: "branchestested")

  branchesUntested: Int! @rename(attribute: "branchesuntested")

  functionsTested: Int! @rename(attribute: "functionstested")

  functionsUntested: Int! @rename(attribute: "functionsuntested")
}

input CoverageFilterInput {
  id: ID
  linesOfCodeTested: Int @rename(attribute: "loctested")
  linesOfCodeUntested: Int @rename(attribute: "locuntested")
  branchesTested: Int @rename(attribute: "branchestested")
  branchesUntested: Int @rename(attribute: "branchesuntested")
  functionsTested: Int @rename(attribute: "functionstested")
  functionsUntested: Int @rename(attribute: "functionsuntested")
}


"""
Label.
"""
type Label {
  "Unique primary key."
  id: ID!

  text: String!
}

input LabelFilterInput {
  id: ID
  text: String
}
