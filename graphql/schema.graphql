"A datetime string with format `Y-m-d H:i:s`, e.g. `2018-05-23 13:43:32`."
scalar DateTime @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\DateTime")


"Indicates what fields are available at the top level of a query operation."
type Query {
  "Find a single project."
  project(
    "Search by primary key."
    id: ID @eq @rules(apply: ["prohibits:name", "required_without:name"])

    "Search by name."
    name: String @eq @rules(apply: ["prohibits:id", "required_without:id"])
  ): Project @find(scopes: ["forUser"])

  "List the projects available to the current user."
  projects(
    id: ID @in
  ): [Project!]! @paginate(scopes: ["forUser"], type: CONNECTION) @orderBy(column: "id")
}


type Mutation {
  "Create a new project."
  createProject(input: CreateProjectInput! @spread): Project @create @canModel(ability: "create")
}


"A registered CDash user.  Can be autogenerated by 3rd-party authentication providers."
type User {
  "Unique primary key."
  id: ID!

  "Non-unique first name."
  firstname: String!

  "Non-unique last name."
  lastname: String!

  "Unique email address."
  email: String!

  "Institution."
  institution: String!

  "Whether or not the user is a global administrator."
  admin: Boolean!
}


"Project."
type Project {
  "Unique primary key."
  id: ID!

  "Unique name."
  name: String!

  "Description."
  description: String!

  "Homepage for this project."
  homeurl: String!

  "Visibility."
  visibility: ProjectVisibility! @rename(attribute: "public")

  "A boolean indicating whether authenticated submissions are required."
  authenticateSubmissions: Boolean! @rename(attribute: "authenticatesubmissions")

  builds: [Build!]! @hasMany(type: CONNECTION) @orderBy(column: "id")

  "The sites which have submitted a build to this project."
  sites: [Site!]! @belongsToMany(type: CONNECTION) @orderBy(column: "id")

  "Users with the administrator role for this project."
  administrators: [User!]! @belongsToMany(type: CONNECTION) @orderBy(column: "id")
}

enum ProjectVisibility {
  "Available to all users and guests."
  PUBLIC @enum(value: 1)

  "Available to all registered users."
  PROTECTED @enum(value: 2)

  "Only available to users added to the project."
  PRIVATE @enum(value: 0)
}

input CreateProjectInput {
  "Unique name."
  name: String!

  "Description."
  description: String!

  "Project homepage"
  homeurl: String!

  "Visibility."
  visibility: ProjectVisibility! @rename(attribute: "public") @rules(attribute: "public", apply: ["App\\Rules\\ProjectVisibilityAllowed"])

  "A boolean indicating whether authenticated submissions are required."
  authenticateSubmissions: Boolean! @rename(attribute: "authenticatesubmissions") @rules(attribute: "authenticatesubmissions", apply: ["App\\Rules\\ProjectAuthenticateSubmissions"])
}


"Build."
type Build {
  "Unique primary key."
  id: ID!

  "Name."
  name: String!

  "Start time."
  startTime: DateTime! @rename(attribute: "starttime")

  "End time."
  endTime: DateTime! @rename(attribute: "endtime")

  "Submission time."
  submissionTime: DateTime! @rename(attribute: "submittime")

  "The buildstamp generated by CTest. Example: 20091218-1414-Experimental"
  stamp: String!

  # TODO: Create a designated UUID GraphQL type
  "UUID."
  uuid: String!

  # TODO: Determine if there are more specific values we can use for this
  "Type."
  buildType: String! @rename(attribute: "type")

  "The version of CTest used to generate this build. Example: ctest-2.9.20091218"
  generator: String!

  "The command used to drive the build. Example: /usr/local/bin/cmake --build . --config Release"
  command: String!

  "The number of errors generated during the configuration step."
  configureErrorsCount: Int @rename(attribute: "configureerrors")

  "The number of warnings generated during the configuration step."
  configureWarningsCount: Int @rename(attribute: "configurewarnings")

  "The duration of the configure step in seconds."
  configureDuration: Int! @rename(attribute: "configureduration")

  "The number of errors generated during the build step."
  buildErrorsCount: Int @rename(attribute: "builderrors")

  "The number of warnings generated during the build step."
  buildWarningsCount: Int @rename(attribute: "buildwarnings")

  "The duration of the build step in seconds."
  buildDuration: Int! @rename(attribute: "buildduration")

  "The number of failed tests."
  failedTestsCount: Int @rename(attribute: "testfailed")

  "The number of tests which failed the time status."
  timeStatusFailedTestsCount: Int @rename(attribute: "testtimestatusfailed")

  "The number of passed tests."
  passedTestsCount: Int @rename(attribute: "testpassed")

  "The number of tests not run for this build."
  notRunTestsCount: Int @rename(attribute: "testnotrun")

  "The duration of the test step in seconds."
  testDuration: Int! @rename(attribute: "testduration")

  "The site associated with this build."
  site: Site! @belongsTo

  "A list of errors submitted for this build."
  errors: [BuildError!]! @hasMany(type: CONNECTION) @orderBy(column: "id", direction: DESC)

  "A list of warnings submitted for this build."
  warnings: [BuildError!]! @hasMany(type: CONNECTION) @orderBy(column: "id", direction: DESC)

  # TODO: Figure out project relation.  project{build{project}} currently throws an error.
}


type BuildError {
  logLine: Int! @rename(attribute: "logline")

  text: String!

  sourceFile: String! @rename(attribute: "sourcefile")

  sourceLine: Int! @rename(attribute: "sourceline")

  preContext: String @rename(attribute: "precontext")

  postContext: String @rename(attribute: "postcontext")
}


type BuildWarning {
  logLine: Int! @rename(attribute: "logline")

  text: String!

  sourceFile: String! @rename(attribute: "sourcefile")

  sourceLine: Int! @rename(attribute: "sourceline")

  preContext: String @rename(attribute: "precontext")

  postContext: String @rename(attribute: "postcontext")
}


"Site."
type Site {
  "Unique primary key."
  id: ID!

  name: String!

  "IP address."
  ip: String!

  latitude: Float!

  longitude: Float!
}
