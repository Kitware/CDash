"A datetime and timezone string in ISO 8601 format `Y-m-dTH:i:sP`, e.g. `2020-04-20T13:53:12+02:00`."
scalar DateTimeTz @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\DateTimeTz")

"A datetime string in ISO 8601 format in UTC with nanoseconds `YYYY-MM-DDTHH:mm:ss.SSSSSSZ`, e.g. `2020-04-20T16:20:04.000000Z`."
scalar DateTimeUtc
@scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\DateTimeUtc")

# It would be better to replace these with a "Duration" scalar type in the future.
"A non-negative decimal number of seconds."
scalar NonNegativeSeconds @scalar(class: "App\\GraphQL\\Scalars\\NonNegativeSeconds")
"A non-negative integer number of milliseconds."
scalar NonNegativeIntegerMilliseconds @scalar(class: "App\\GraphQL\\Scalars\\NonNegativeIntegerMilliseconds")


"Indicates what fields are available at the top level of a query operation."
type Query {
  "Find a single user by ID."
  me: User @auth

  "Find a single user by ID."
  user(
    id: ID @eq
  ): User @find

  "Get multiple users."
  users(
    filters: _ @filter
  ): [User!]! @paginate(type: CONNECTION) @orderBy(column: "id")

  "Find a single project."
  project(
    "Search by primary key."
    id: ID @eq @rules(apply: ["prohibits:name", "required_without:name"])

    "Search by name."
    name: String @eq @rules(apply: ["prohibits:id", "required_without:id"])
  ): Project @find(scopes: ["forUser"])

  "List the projects available to the current user."
  projects(
    filters: _ @filter
  ): [Project!]! @paginate(scopes: ["forUser"], type: CONNECTION) @orderBy(column: "id")

  "Find a single build by ID."
  build(
    "Search by primary key."
    id: ID @eq
  ): Build @find @canResolved(ability: "view")

  """
  Find a single site by ID.  All sites are currently public (although not necessarily
  the projects they contribute to).  In the future, the concept of "private sites"
  may be a good feature to add.
  """
  site(
    "Search by primary key."
    id: ID @eq
  ): Site @find

  invitations: [GlobalInvitation!]! @canResolved(ability: "viewInvitations") @paginate(type: CONNECTION) @orderBy(column: "id")
}


type Mutation {
  "Create a new project."
  createProject(input: CreateProjectInput! @spread): Project @create @canModel(ability: "create")

  "Subscribe the current user to the specified site."
  claimSite(input: ClaimSiteInput! @spread): ClaimSiteMutationPayload! @field(resolver: "ClaimSite")

  "Unsubscribe the current user from the specified site."
  unclaimSite(input: UnclaimSiteInput! @spread): UnclaimSiteMutationPayload! @field(resolver: "UnclaimSite")

  "Edit the site description."
  updateSiteDescription(input: UpdateSiteDescriptionInput! @spread): UpdateSiteDescriptionMutationPayload! @field(resolver: "UpdateSiteDescription")

  "Add users to a project."
  inviteToProject(input: InviteToProjectInput! @spread): InviteToProjectMutationPayload! @field(resolver: "InviteToProject")

  "Revoke an outstanding project invitation."
  revokeProjectInvitation(input: RevokeProjectInvitationInput! @spread): RevokeProjectInvitationMutationPayload! @field(resolver: "RevokeProjectInvitation")

  "Change an existing user's role in a project."
  changeProjectRole(input: ChangeProjectRoleInput! @spread): ChangeProjectRoleMutationPayload! @field(resolver: "ChangeProjectRole")

  "Remove a user from a project."
  removeProjectUser(input: RemoveProjectUserInput! @spread): RemoveProjectUserMutationPayload! @field(resolver: "RemoveProjectUser")

  "Join a project directly.  Only useful for public and protected projects.  Use invitations to add users to private projects."
  joinProject(input: JoinProjectInput! @spread): JoinProjectMutationPayload! @field(resolver: "JoinProject")

  "Invite a user to this CDash instance by email."
  createGlobalInvitation(input: CreateGlobalInvitationInput! @spread): CreateGlobalInvitationMutationPayload! @field(resolver: "CreateGlobalInvitation")

  "Revoke an outstanding invitation."
  revokeGlobalInvitation(input: RevokeGlobalInvitationInput! @spread): RevokeGlobalInvitationMutationPayload! @field(resolver: "RevokeGlobalInvitation")

  "Change an existing user's site-wide role."
  changeGlobalRole(input: ChangeGlobalRoleInput! @spread): ChangeGlobalRoleMutationPayload! @field(resolver: "ChangeGlobalRole")

  "Delete a user."
  removeUser(input: RemoveUserInput! @spread): RemoveUserMutationPayload! @field(resolver: "RemoveUser")
}


interface MutationPayloadInterface {
  "Optional error message."
  message: String
}


"A registered CDash user.  Can be autogenerated by 3rd-party authentication providers."
type User {
  "Unique primary key."
  id: ID! @filterable

  "Non-unique first name."
  firstname: String! @filterable

  "Non-unique last name."
  lastname: String! @filterable

  # We deliberately disallow filtering on the email to prevent information leakage.
  "Unique email address."
  email: String @canRoot(ability: "viewEmail", action: RETURN_VALUE, returnValue: null)

  "Institution."
  institution: String! @filterable

  "Whether or not the user is a global administrator."
  admin: Boolean! @filterable
}


"Project."
type Project {
  "Unique primary key."
  id: ID! @filterable

  "Unique name."
  name: String! @filterable

  "Description."
  description: String!

  "Homepage for this project."
  homeurl: String!

  "Visibility."
  visibility: ProjectVisibility! @rename(attribute: "public") @filterable

  "A boolean indicating whether authenticated submissions are required."
  authenticateSubmissions: Boolean! @rename(attribute: "authenticatesubmissions")

  "A LDAP group users must be a member of to access the project."
  ldapFilter: String @rename(attribute: "ldapfilter")

  builds(
    filters: _ @filter
  ): [Build!]! @hasMany(type: CONNECTION) @orderBy(column: "id")

  """
  An efficient way to get the number of builds matching a given filter.
  """
  buildCount(
    filters: _ @filter(inputType: "BuildFilterInput")
  ): Int! @count(relation: "builds")

  """
  The most recent build submitted to this server.  Note: this is determined by
  submission time, not build start time.
  """
  mostRecentBuild: Build @hasOne

  "The sites which have submitted a build to this project."
  sites(
    filters: _ @filter
  ): [Site!]! @belongsToMany(type: CONNECTION) @orderBy(column: "id")

  "Users with the lowest user role for this project."
  basicUsers: [User!]! @belongsToMany(type: CONNECTION) @orderBy(column: "id")

  "Users with the administrator role for this project."
  administrators: [User!]! @belongsToMany(type: CONNECTION) @orderBy(column: "id")

  # Can't return null on authorization failure due to Lighthouse bug with connections and can* directives.
  "Invitations to this project which have not been accepted yet."
  invitations: [ProjectInvitation!]! @canRoot(ability: "inviteUser") @hasMany(type: CONNECTION) @orderBy(column: "id")
}

enum ProjectVisibility {
  "Available to all users and guests."
  PUBLIC @enum(value: 1)

  "Available to all registered users."
  PROTECTED @enum(value: 2)

  "Only available to users added to the project."
  PRIVATE @enum(value: 0)
}

input CreateProjectInput {
  "Unique name."
  name: String!

  "Description."
  description: String!

  "Project homepage"
  homeurl: String!

  "Visibility."
  visibility: ProjectVisibility! @rename(attribute: "public") @rules(attribute: "public", apply: ["App\\Rules\\ProjectVisibilityAllowed"])

  "A boolean indicating whether authenticated submissions are required."
  authenticateSubmissions: Boolean! @rename(attribute: "authenticatesubmissions") @rules(attribute: "authenticatesubmissions", apply: ["App\\Rules\\ProjectAuthenticateSubmissions"])

  "A LDAP group users must be a member of to access the project."
  ldapFilter: String @rename(attribute: "ldapfilter")
}


type ProjectInvitation {
  id: ID!

  email: String!

  invitedBy: User! @belongsTo

  project: Project! @belongsTo

  role: ProjectRole!

  invitationTimestamp: DateTimeTz! @rename(attribute: "invitation_timestamp")
}


input InviteToProjectInput {
  email: String!
  projectId: ID!
  role: ProjectRole!
}


type InviteToProjectMutationPayload implements MutationPayloadInterface {
  "Optional error message."
  message: String

  invitedUser: ProjectInvitation
}


input RevokeProjectInvitationInput {
  invitationId: ID!
}


type RevokeProjectInvitationMutationPayload implements MutationPayloadInterface {
  "Optional error message."
  message: String
}


input ChangeProjectRoleInput {
  userId: ID!
  projectId: ID!
  role: ProjectRole!
}


type ChangeProjectRoleMutationPayload implements MutationPayloadInterface {
  "Optional error message."
  message: String

  "The user whose role was changed."
  user: User

  "The project associated with the user whose role was changed."
  project: Project
}


input RemoveProjectUserInput {
  userId: ID!
  projectId: ID!
}


type RemoveProjectUserMutationPayload implements MutationPayloadInterface {
  "Optional error message."
  message: String
}


input JoinProjectInput {
  projectId: ID!
}


type JoinProjectMutationPayload implements MutationPayloadInterface {
  "Optional error message."
  message: String
}


type GlobalInvitation {
  id: ID!

  email: String!

  invitedBy: User! @belongsTo

  role: GlobalRole!

  invitationTimestamp: DateTimeTz! @rename(attribute: "invitation_timestamp")
}


input CreateGlobalInvitationInput {
  email: String!
  role: GlobalRole!
}


type CreateGlobalInvitationMutationPayload implements MutationPayloadInterface {
  "Optional error message."
  message: String

  invitedUser: GlobalInvitation
}


input RevokeGlobalInvitationInput {
  invitationId: ID!
}


type RevokeGlobalInvitationMutationPayload implements MutationPayloadInterface {
  "Optional error message."
  message: String
}


input ChangeGlobalRoleInput {
  userId: ID!
  role: GlobalRole!
}


type ChangeGlobalRoleMutationPayload implements MutationPayloadInterface {
  "Optional error message."
  message: String

  "The user whose role was changed."
  user: User
}


input RemoveUserInput {
  userId: ID!
}


type RemoveUserMutationPayload implements MutationPayloadInterface {
  "Optional error message."
  message: String
}


"Build."
type Build {
  "Unique primary key."
  id: ID! @filterable

  "Name."
  name: String! @filterable

  "Start time."
  startTime: DateTimeTz! @rename(attribute: "starttime") @filterable

  "End time."
  endTime: DateTimeTz! @rename(attribute: "endtime") @filterable

  "Submission time."
  submissionTime: DateTimeTz! @rename(attribute: "submittime") @filterable

  "The buildstamp generated by CTest. Example: 20091218-1414-Experimental"
  stamp: String! @filterable

  # TODO: Create a designated UUID GraphQL type
  "UUID."
  uuid: String! @filterable

  # TODO: Determine if there are more specific values we can use for this
  "Type."
  buildType: String! @rename(attribute: "type")

  "The version of CTest used to generate this build. Example: ctest-2.9.20091218"
  generator: String! @filterable

  "The command used to drive the build. Example: /usr/local/bin/cmake --build . --config Release"
  command: String! @filterable

  "The number of errors generated during the configuration step."
  configureErrorsCount: Int @rename(attribute: "configureerrors")

  "The number of warnings generated during the configuration step."
  configureWarningsCount: Int @rename(attribute: "configurewarnings")

  "The duration of the configure step in seconds."
  configureDuration: Int! @rename(attribute: "configureduration")

  "The number of errors generated during the build step."
  buildErrorsCount: Int @rename(attribute: "builderrors")

  "The number of warnings generated during the build step."
  buildWarningsCount: Int @rename(attribute: "buildwarnings")

  "The duration of the build step in seconds."
  buildDuration: Int! @rename(attribute: "buildduration")

  "The number of failed tests."
  failedTestsCount: Int @rename(attribute: "testfailed")

  "The number of tests which failed the time status."
  timeStatusFailedTestsCount: Int @rename(attribute: "testtimestatusfailed")

  "The number of passed tests."
  passedTestsCount: Int @rename(attribute: "testpassed")

  "The number of tests not run for this build."
  notRunTestsCount: Int @rename(attribute: "testnotrun")

  "The duration of the test step in seconds."
  testDuration: Int! @rename(attribute: "testduration")

  "The site associated with this build."
  site: Site! @belongsTo

  "Test results associated with this build."
  tests(
    filters: _ @filter
  ): [Test!]! @hasMany(type: CONNECTION) @orderBy(column: "id", direction: DESC)

  # TODO: Make an "errors" field which returns the union of basic and rich errors
  """
  A list of "basic" errors submitted for this build.
  """
  basicErrors: [BasicBuildAlert!]! @hasMany(type: CONNECTION) @orderBy(column: "id", direction: DESC)

  # TODO: Make a "warnings" field which returns the union of basic and rich warnings
  """
  A list of "basic" warnings submitted for this build.
  """
  basicWarnings: [BasicBuildAlert!]! @hasMany(type: CONNECTION) @orderBy(column: "id", direction: DESC)

  project: Project! @belongsTo

  notes: [Note!]! @belongsToMany(type: CONNECTION) @orderBy(column: "id", direction: DESC)

  operatingSystemName: String @rename(attribute: "osname") @filterable

  operatingSystemPlatform: String @rename(attribute: "osplatform") @filterable

  operatingSystemRelease: String @rename(attribute: "osrelease") @filterable

  operatingSystemVersion: String @rename(attribute: "osversion") @filterable

  compilerName: String @rename(attribute: "compilername") @filterable

  compilerVersion: String @rename(attribute: "compilerversion") @filterable

  """
  Child builds associated with this parent build.  Note that CDash only supports one level of
  subprojects, so no child builds will have children of their own.
  """
  children(
    filters: _ @filter
  ): [Build!]! @hasMany(type: CONNECTION) @orderBy(column: "id")

  coverageResults(
    filters: _ @filter
  ): [Coverage!]! @belongsToMany(type: CONNECTION, relation: "coverage") @orderBy(column: "id", direction: DESC) @deprecated(reason: "Use 'coverage' instead.")

  coverage(
    filters: _ @filter
  ): [Coverage!]! @belongsToMany(type: CONNECTION) @orderBy(column: "id", direction: DESC)

  """
  Get the percentage of lines covered in all files starting with the provided path.
  Automatically trims leading slashes and dots.  Returns null if the directory does
  not exist or contains no lines of executable code.
  """
  percentCoverageForPath(
    path: String!
  ): Float @method

  labels(
    filters: _ @filter
  ): [Label!]! @belongsToMany(type: CONNECTION) @orderBy(column: "id", direction: DESC)

  targets(
    filters: _ @filter
  ): [Target!]! @hasMany(type: CONNECTION) @orderBy(column: "id", direction: ASC)

  commands(
    filters: _ @filter
  ): [BuildCommand!]! @hasMany(type: CONNECTION) @orderBy(column: "id", direction: ASC)

  urls: [UploadedUrl!]! @hasMany(relation: "uploadedFiles", type: CONNECTION, scopes: ["urls"]) @orderBy(column: "id", direction: ASC)

  files: [UploadedFile!]! @hasMany(relation: "uploadedFiles", type: CONNECTION, scopes: ["files"]) @orderBy(column: "id", direction: ASC)

  subProject: SubProject! @belongsTo
}


"Test."
type Test {
  "Unique primary key."
  id: ID! @filterable

  name: String! @rename(attribute: "testname") @filterable

  status: TestStatus! @filterable

  timeStatusCategory: TestTimeStatusCategory! @rename(attribute: "timestatuscategory") @filterable

  runningTime: NonNegativeSeconds! @rename(attribute: "time") @filterable

  details: String! @filterable

  """
  Test measurements for this test, sorted in descending order so newer results
  appear first when using paginated queries.
  """
  testMeasurements: [TestMeasurement!]! @hasMany(type: CONNECTION) @orderBy(column: "id", direction: DESC)

  labels(
    filters: _ @filter
  ): [Label!]! @belongsToMany(type: CONNECTION) @orderBy(column: "id", direction: DESC)
}

enum TestStatus {
  PASSED @enum(value: "passed")

  FAILED @enum(value: "failed")

  NOT_RUN @enum(value: "notrun")
}


"Test Measurement."
type TestMeasurement {
  "Unique primary key."
  id: ID!

  """
  Example: "Exit Value"
  """
  name: String!

  """
  Example: "text/string", "numeric/double", "text/preformatted", etc
  """
  type: String!

  """
  The value for this measurement.  Even though some values may be numeric, all
  values are returned as strings.  There is no guarantee that the type field
  will match the actual type of the value field.

  Example: "5"
  """
  value: String!
}


"""
Represents a command run during the build step.

https://cmake.org/cmake/help/git-master/manual/cmake-instrumentation.7.html#v1-snippet-file
"""
type BuildCommand @model(class: "App\\Models\\BuildCommand") {
  id: ID! @filterable

  type: BuildCommandType! @filterable

  startTime: DateTimeUtc! @rename(attribute: "starttime") @filterable

  duration: NonNegativeIntegerMilliseconds! @filterable

  command: String! @filterable

  workingDirectory: String! @rename(attribute: "workingdirectory") @filterable

  result: String! @filterable

  source: String @filterable

  language: String @filterable

  config: String @filterable

  target: Target @belongsTo

  measurements(
    filters: _ @filter
  ): [BuildMeasurement!]! @hasMany(type: CONNECTION) @orderBy(column: "id", direction: ASC)

  """
  Output filenames and corresponding sizes associated with this command.  Most command types only
  produce one output file.
  """
  outputs(
    filters: _ @filter
  ): [BuildCommandOutput!]! @hasMany(type: CONNECTION) @orderBy(column: "id", direction: ASC)
}


"Build Measurement."
type BuildMeasurement {
  "Unique primary key."
  id: ID! @filterable

  name: String! @filterable

  type: String! @filterable

  """
  The value for this measurement.  Even though some values may be numeric, all
  values are returned as strings.  The type of the value field is not guaranteed
  to match the actual type of the value field.

  Example: "5"
  """
  value: String! @filterable
}


"An individual file produced by a build command."
type BuildCommandOutput {
  "Unique primary key."
  id: ID! @filterable

  "Output filename."
  name: String! @filterable

  "Output file size in bytes."
  size: Int! @filterable
}


"""
"Basic" alerts are warnings or errors scraped from the build log, as opposed to "rich" alerts which
come from CTest launchers.  A given build should either have all "basic" alerts or all "rich" alerts.
Users should take both types into account when querying the alerts for a given build.

https://cmake.org/cmake/help/latest/manual/ctest.1.html#ctest-build-step
"""
type BasicBuildAlert {
  logLine: Int! @rename(attribute: "logline")

  text: String!

  sourceFile: String! @rename(attribute: "sourcefile")

  sourceLine: Int! @rename(attribute: "sourceline")

  preContext: String @rename(attribute: "precontext")

  postContext: String @rename(attribute: "postcontext")
}


"Site."
type Site {
  "Unique primary key."
  id: ID! @filterable

  name: String! @filterable

  "IP address."
  ip: String! @filterable

  latitude: String! @filterable

  longitude: String! @filterable

  "Every edit of this site's information."
  information: [SiteInformation!]! @hasMany(type: CONNECTION) @orderBy(column: "timestamp", direction: DESC)

  "The most recent information we have about this site."
  # TODO: Figure out how to support the date parameter. Perhaps it would be better to use a scope instead.
  mostRecentInformation: SiteInformation @hasOne

  "The users who have signed up to maintain this site."
  maintainers(
    filters: _ @filter
  ): [User!]! @belongsToMany(type: CONNECTION) @orderBy(column: "id")
}

input ClaimSiteInput {
  siteId: ID!
}

type ClaimSiteMutationPayload implements MutationPayloadInterface {
  "Optional error message."
  message: String

  "Site being claimed."
  site: Site

  "The user claiming the requested site."
  user: User
}

type UnclaimSiteMutationPayload implements MutationPayloadInterface {
  "Optional error message."
  message: String

  "Site being unclaimed."
  site: Site

  "The user being detached from the requested site."
  user: User
}

input UnclaimSiteInput {
  siteId: ID!
}

input UpdateSiteDescriptionInput {
  siteId: ID!
  description: String!
}

type UpdateSiteDescriptionMutationPayload implements MutationPayloadInterface {
  "Optional error message."
  message: String

  site: Site
}


"Details about a site at a given point in time."
type SiteInformation {
  "Unique primary key."
  id: ID!

  "Creation timestamp."
  timestamp: DateTimeTz!

  processorIs64Bits: Boolean @rename(attribute: "processoris64bits")

  processorVendor: String @rename(attribute: "processorvendor")

  processorVendorId: String @rename(attribute: "processorvendorid")

  processorFamilyId: Int @rename(attribute: "processorfamilyid")

  processorModelId: Int @rename(attribute: "processormodelid")

  processorModelName: String @rename(attribute: "processormodelname")

  processorCacheSize: Int @rename(attribute: "processorcachesize")

  numberLogicalCpus: Int @rename(attribute: "numberlogicalcpus")

  numberPhysicalCpus: Int @rename(attribute: "numberphysicalcpus")

  "Virtual memory in MiB."
  totalVirtualMemory: Int @rename(attribute: "totalvirtualmemory")

  "Physical memory in MiB."
  totalPhysicalMemory: Int @rename(attribute: "totalphysicalmemory")

  logicalProcessorsPerPhysical: Int @rename(attribute: "logicalprocessorsperphysical")

  "Clock frequency in MHz."
  processorClockFrequency: Int @rename(attribute: "processorclockfrequency")

  description: String
}


"""
Note.
"""
type Note {
  "Unique primary key."
  id: ID! @filterable

  name: String! @filterable

  text: String! @filterable
}


"""
Coverage result for a particular build+file combination.
"""
type Coverage @model(class: "App\\Models\\CoverageView") {
  "Unique primary key."
  id: ID! @filterable

  linesOfCodeTested: Int! @rename(attribute: "loctested") @filterable

  linesOfCodeUntested: Int! @rename(attribute: "locuntested") @filterable

  branchesTested: Int! @rename(attribute: "branchestested") @filterable

  branchesUntested: Int! @rename(attribute: "branchesuntested") @filterable

  functionsTested: Int! @rename(attribute: "functionstested") @filterable

  functionsUntested: Int! @rename(attribute: "functionsuntested") @filterable

  filePath: String @rename(attribute: "fullpath") @filterable

  file: String @filterable @canRoot(ability: "viewCode", action: RETURN_VALUE, returnValue: null)

  # Note: we deliberately don't use pagination here because the server has to load the entire file
  # in full anyway, and each record is small.
  coveredLines: [CoverageLine]!

  labels(
    filters: _ @filter
  ): [Label!]! @belongsToMany(type: CONNECTION) @orderBy(column: "id", direction: DESC)
}


"""
Coverage information for an individual line.
"""
type CoverageLine {
  lineNumber: Int!
  timesHit: Int
  totalBranches: Int
  branchesHit: Int
}


"""
Label.
"""
type Label {
  "Unique primary key."
  id: ID! @filterable

  text: String! @filterable
}


"""
Target.
"""
type Target {
  "Unique primary key."
  id: ID! @filterable

  name: String! @filterable

  """
  https://cmake.org/cmake/help/latest/prop_tgt/TYPE.html
  """
  type: TargetType! @filterable

  commands(
    filters: _ @filter
  ): [BuildCommand!]! @hasMany(type: CONNECTION) @orderBy(column: "id", direction: ASC)

  labels(
    filters: _ @filter
  ): [Label!]! @belongsToMany(type: CONNECTION) @orderBy(column: "id", direction: DESC)
}


type UploadedUrl @model(class: "App\\Models\\UploadFile") {
  "Unique primary key."
  id: ID!

  href: String! @rename(attribute: "filename")
}


type UploadedFile @model(class: "App\\Models\\UploadFile") {
  "Unique primary key.  Use /builds/<id>/files/<id> to download the file by ID."
  id: ID!

  name: String! @rename(attribute: "filename")

  sha1sum: String!

  "File size in bytes."
  size: Int! @rename(attribute: "filesize")
}


# TODO: add the rest of the fields once types and relationships are solidified.
type SubProject {
  "Unique primary key."
  id: ID!

  name: String!
}
